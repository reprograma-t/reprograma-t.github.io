<!DOCTYPE html>
<html lang="pt-BR" dir="ltr"> <!-- Adicionado dir="ltr" para acessibilidade -->
<head>
    <!-- Meta Tags Básicas -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Manifesto 'Também Podemos Sonhar' - Uma iniciativa de travestis criando tecnologia, educação e inclusão através do Orby Chat.">
    <meta name="keywords" content="travestis, tecnologia, inclusão, Orby Chat, Kelly, Larissa, Luanny, diversidade, empreendedorismo LGBTQIA+, manifesto">
    <meta name="author" content="Orby Chat">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <!-- IMPORTANTE: Atualize esta URL para a URL final onde o manifesto será hospedado -->
    <meta property="og:url" content="https://reprograma-t.github.io/manifesto">
    <meta property="og:title" content="Também Podemos Sonhar - Manifesto Orby Chat">
    <meta property="og:description" content="Travestis criando tecnologia, educação e um futuro mais inclusivo. Conheça nosso manifesto.">
    <!-- IMPORTANTE: Crie e hospede esta imagem no caminho especificado -->
    <meta property="og:image" content="https://reprograma-t.github.io/logo.png"> <!-- Imagem 1200x630px recomendada -->

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <!-- IMPORTANTE: Atualize esta URL para a URL final onde o manifesto será hospedado -->
    <meta name="twitter:url" content="https://reprograma-t.github.io/manifesto">
    <meta name="twitter:title" content="Também Podemos Sonhar - Manifesto Orby Chat">
    <meta name="twitter:description" content="Travestis criando tecnologia, educação e um futuro mais inclusivo. Conheça nosso manifesto.">
    <!-- IMPORTANTE: Crie e hospede esta imagem no caminho especificado -->
    <meta name="twitter:image" content="https://reprograma-t.github.io/logo.png"> <!-- Imagem 1200x630px recomendada -->

    <!-- Favicon e ícones -->
    <!-- IMPORTANTE: Crie e hospede estes ícones nos caminhos especificados -->
    <link rel="icon" type="image/png" sizes="32x32" href="https://reprograma-t.github.io/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://reprograma-t.github.io/favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="https://reprograma-t.github.io/apple-touch-icon.png">
    <!-- Opcional: Crie um arquivo manifest.json para PWA -->
    <link rel="manifest" href="https://reprograma-t.github.io/site.webmanifest">

    <!-- Título otimizado -->
    <title>Também Podemos Sonhar - Manifesto Orby Chat por Kelly, Larissa e Luanny</title>

    <!-- Fontes -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;700;900&display=swap" rel="stylesheet">

    <!-- Estilos CSS -->
    <style>
        :root {
            --background-color-dark: #1a1a2e; /* Cor de fundo escura */
            --background-color-light: #f0f0f0; /* Cor de fundo clara */
            --text-color: #ffffff;             /* Cor do texto padrão (para fundo escuro) */
            --accent-color: #e94560;           /* Cor de destaque */
            --glitch-color-1: #0ff;            /* Cor 1 para efeito glitch (ciano) */
            --glitch-color-2: #f0f;            /* Cor 2 para efeito glitch (magenta) */
            --transition-speed: 0.8s;          /* Velocidade da transição padrão */
            --line-delay: 1.5s;                /* Tempo entre linhas consecutivas em uma seção (em segundos) */
            --section-delay: 2s;               /* Tempo entre mostrar seções (em segundos) */
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            color: var(--text-color);
            background-color: var(--background-color-dark);
            overflow: hidden; /* Esconder barras de rolagem */
            transition: background-color var(--transition-speed) ease-in-out; /* Transição suave da cor de fundo */
        }

        /* Usar <main> para semântica e acessibilidade */
        #manifesto-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        .manifesto-section {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            text-align: center;
            opacity: 0; /* Inicialmente oculto */
            visibility: hidden; /* Inicialmente oculto e fora do fluxo de acessibilidade */
            transition: opacity var(--transition-speed) ease-in-out, visibility var(--transition-speed) ease-in-out;
            background: var(--background-color-dark); /* Fundo padrão */
        }

        .manifesto-section.active {
            opacity: 1;
            visibility: visible; /* Torna visível quando ativo */
        }

        .line {
            opacity: 0; /* Inicialmente oculto */
            transform: translateY(20px); /* Começa ligeiramente abaixo */
            transition: opacity 0.8s ease-out, transform 0.8s ease-out; /* Animação de fade-in e subida */
            margin: 10px 0;
            font-size: 1.5em; /* Tamanho de fonte base para as linhas */
            max-width: 800px; /* Largura máxima para melhor legibilidade */
            line-height: 1.4; /* Espaçamento entre linhas */
        }

        .line.visible {
            opacity: 1;
            transform: translateY(0); /* Posição final */
        }

        /* Estilos Específicos da Seção & Animações */

        /* Introdução */
        #intro {
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), var(--background-color-dark));
        }

        /* Problema */
        #problem {
            background: #2c394b;
        }

        /* Fundadoras */
        #founders .founders-names .line {
            font-size: 2em;
            font-weight: 700;
        }
        #founders .project-intro {
            font-size: 1.8em;
            margin-top: 30px;
        }
        #founders .orby-text {
            color: var(--accent-color);
            font-weight: 900;
        }

        /* Detalhes do Projeto */
        /* (Nenhum estilo específico além do padrão) */

        /* Objetivo */
        #goal {
            background: #120a2e; /* Tom roxo escuro para esta seção */
        }
        .glitch-container {
            position: relative;
            display: inline-block;
        }
        .glitch-text {
            position: relative;
            font-size: 2em;
            font-weight: 900;
            color: var(--text-color); /* Texto original permanece visível (branco) */
        }

        /* Animação Glitch (CORRIGIDA) */
        @keyframes glitch {
            0% { clip-path: inset(40% 0 40% 0); transform: translateX(-1px); }
            10% { clip-path: inset(80% 0 5% 0); transform: translateX(1px); }
            20% { clip-path: inset(10% 0 70% 0); transform: translateX(-1px); }
            30% { clip-path: inset(60% 0 10% 0); transform: translateX(1px); }
            40% { clip-path: inset(10% 0 60% 0); transform: translateX(-2px); }
            50% { clip-path: inset(80% 0 5% 0); transform: translateX(2px); }
            60% { clip-path: inset(20% 0 50% 0); transform: translateX(-1px); }
            70% { clip-path: inset(70% 0 20% 0); transform: translateX(1px); }
            80% { clip-path: inset(5% 0 80% 0); transform: translateX(-2px); }
            90% { clip-path: inset(40% 0 40% 0); transform: translateX(2px); }
            100% { clip-path: inset(80% 0 5% 0); transform: translateX(-1px); }
        }

        .glitch-container::before,
        .glitch-container::after {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* background: transparent; /* CORRIGIDO: Sem background */
            color: var(--text-color); /* Cor base do texto nos pseudo-elementos (pode ser a mesma) */
            overflow: hidden; /* Garante que o clip-path funcione */
            pointer-events: none;
        }

        .glitch-container::before {
            left: -2px;
            text-shadow: 2px 0 var(--glitch-color-1); /* Sombra Ciano */
            /* A animação só será aplicada quando .active estiver presente */
            animation: none;
        }

        .glitch-container::after {
            left: 2px;
            text-shadow: -2px 0 var(--glitch-color-2); /* Sombra Magenta */
             /* A animação só será aplicada quando .active estiver presente */
            animation: none;
        }

        /* Aplica a animação APENAS quando o container está ativo */
        .glitch-container.active::before {
            animation: glitch 0.4s infinite linear alternate-reverse; /* Duração ajustada */
        }
        .glitch-container.active::after {
            animation: glitch 0.4s infinite linear alternate; /* Duração ajustada */
        }

        /* CORRIGIDO: Não precisamos mais esconder o texto original
        .glitch-container.active .glitch-text.visible {
            color: transparent;
        } */

        /* Garante que os pseudo-elementos tenham conteúdo quando ativos */
        .glitch-container.active::before,
        .glitch-container.active::after {
             content: attr(data-text);
        }
        /* Esconde os pseudo-elementos quando não ativos (bom para performance) */
        .glitch-container:not(.active)::before,
        .glitch-container:not(.active)::after {
             content: none;
             animation: none; /* Garante que a animação pare */
        }


        /* Luta/Futuro */
        #struggle-future {
            background: #3a2a3b; /* Tom mais escuro e rico, arroxeado */
            position: relative; /* Para posicionar as frases de sobreposição */
        }
        #struggle-future .line {
            position: relative; /* Garante que o texto principal esteja acima das frases de sobreposição */
            z-index: 1;
        }
        .overlay-phrases {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: space-around; /* Distribui as frases verticalmente */
            align-items: center;
            font-size: 3em; /* Tamanho grande */
            font-weight: 900; /* Bem forte */
            color: rgba(255, 255, 255, 0.1); /* Sutil, como marca d'água */
            pointer-events: none; /* Não interage com o mouse */
            z-index: 0; /* Fica atrás do texto principal */
        }
        .overlay-phrase {
            opacity: 0; /* Começa invisível */
            transform: scale(0.8); /* Começa menor */
            transition: opacity 1s ease-out, transform 1s ease-out; /* Animação suave */
        }
        .overlay-phrase.visible {
            opacity: 0.2; /* Torna um pouco mais visível quando ativo */
            transform: scale(1); /* Tamanho normal */
        }

        /* Determinação */
        #determination {
            background: #1f2833; /* Cor forte e sólida */
        }
        #determination .line {
             font-size: 1.8em;
             font-weight: 300;
             margin: 20px 0;
             transition: opacity 1s ease-out, transform 1s ease-out, font-weight 1s ease-out, color 1s ease-out;
        }
        #determination .line:nth-child(2).visible {
            font-weight: 700;
        }
        #determination .line:nth-child(3).visible {
             font-weight: 900;
             color: var(--accent-color);
        }


        /* Transformação */
        #transformation {
            background: linear-gradient(45deg, #e94560, #ff7e5f, #feb47b, #86a8e7, #91eacb); /* Gradiente vibrante */
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
        }
        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        #transformation .line {
            font-size: 1.6em;
        }
        #transformation .build-more {
             font-size: 2em;
             font-weight: 700;
        }
        .product-list {
            margin-top: 40px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
        }
        .product-item {
            padding: 10px 20px;
            border: 2px solid var(--text-color);
            border-radius: 5px;
            opacity: 0;
            transform: scale(0.9);
            transition: opacity 0.6s ease-out, transform 0.6s ease-out;
            font-weight: 700;
        }
        .product-item.visible {
            opacity: 1;
            transform: scale(1);
        }


        /* Processo */
        #process {
             background: #0a1a1a; /* Sensação de tecnologia/código */
        }
        #process .line {
             font-family: monospace;
             white-space: pre;
             overflow: hidden;
             border-right: .15em solid orange; /* Cursor de digitação */
             animation: none; /* Sobrescreve animação padrão */
             margin: 20px auto;
             width: fit-content; /* Ajusta largura ao conteúdo */
        }
        #process .line.typing {
             /* Duração da digitação baseada no JS, cursor pisca aqui */
             animation: blink-caret .75s step-end infinite;
             width: fit-content;
        }
        /* Animação de digitação será controlada via JS para sincronia */
        @keyframes typing {
            from { width: 0 }
            to { width: 100% }
        }
        @keyframes blink-caret {
            from, to { border-color: transparent }
            50% { border-color: orange }
        }
        #process .line.typing.visible {
             opacity: 1;
             transform: none;
        }
        #process .line:not(.typing) {
             border-right: none; /* Esconde cursor quando não digita */
        }


        /* Clímax */
        #climax {
            background: var(--background-color-dark);
            transition: background-color 1s ease-in-out, opacity var(--transition-speed) ease-in-out, visibility var(--transition-speed) ease-in-out;
        }
        #climax.active {
             background: var(--background-color-light); /* Transição para branco */
        }
        #climax .big-text {
            font-size: 4em;
            font-weight: 900;
            color: var(--text-color);
            transition: color 1s ease-in-out;
        }
        #climax.active .big-text {
            color: var(--background-color-dark); /* Muda cor do texto no fundo branco */
        }


        /* Final */
        #ending {
            background: var(--background-color-light);
            color: var(--background-color-dark);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        #ending .line {
            color: var(--background-color-dark);
        }
        .logo-animation {
            margin-bottom: 40px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #orby-logo {
            width: 150px;
            height: auto;
            margin-bottom: 20px;
            opacity: 0;
            transform: scale(0.8);
            transition: opacity 1.5s ease-out, transform 1.5s ease-out;
            /* Atraso via JS/ativação da seção */
        }
        #ending.active #orby-logo {
            opacity: 1;
            transform: scale(1);
        }
        .tagline {
            margin-top: 10px;
            font-size: 1.2em;
            font-weight: 700;
            color: var(--background-color-dark);
        }
        .tagline-word {
            display: inline-block;
            opacity: 0;
            transform: translateX(-20px);
            transition: opacity 0.6s ease-out, transform 0.6s ease-out;
            margin: 0 5px;
        }
        /* Atraso via CSS quando a seção está ativa */
        #ending.active .tagline-word:nth-child(1) { transition-delay: 2.5s; }
        #ending.active .tagline-word:nth-child(2) { transition-delay: 2.8s; }
        #ending.active .tagline-word:nth-child(3) { transition-delay: 3.1s; }
        #ending.active .tagline-word {
             opacity: 1;
             transform: translateX(0);
        }
        .call-to-action {
            margin-top: 40px;
        }
        #ending .cta-line {
            color: var(--background-color-dark);
            font-size: 1.3em;
        }

        /* Opcional: Estilos para botões de compartilhamento (se adicionados) */
        .share-buttons {
            margin-top: 30px;
            display: flex;
            gap: 15px;
        }
        .share-button {
            /* Estilizar botões aqui */
            padding: 8px 15px;
            background-color: var(--background-color-dark);
            color: var(--background-color-light);
            text-decoration: none;
            border-radius: 5px;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        .share-button:hover {
            background-color: var(--accent-color);
        }

    </style>
    <!-- Import Map (se necessário para módulos JS futuros) -->
    <script type="importmap">
      {
        "imports": {
        }
      }
    </script>
</head>
<body>
    <!-- Usar <main> para conteúdo principal por semântica e acessibilidade -->
    <main id="manifesto-container" aria-label="Manifesto Também Podemos Sonhar">

        <!-- Seção 1: Intro -->
        <section id="intro" class="manifesto-section" aria-labelledby="intro-line-1">
            <p class="line" id="intro-line-1">“Há homens. Há mulheres. Mas onde estão as travestis... nos lugares de poder?”</p>
        </section>

        <!-- Seção 2: Problema -->
        <section id="problem" class="manifesto-section" aria-labelledby="problem-line-1">
            <p class="line" id="problem-line-1">“Não por falta de talento, mas por falta de acesso, de respeito... de espaço.”</p>
        </section>

        <!-- Seção 3: Fundadoras -->
        <section id="founders" class="manifesto-section" aria-labelledby="founders-intro">
             <div class="founders-names" aria-label="Fundadoras">
                <p class="line name">Kelly.</p>
                <p class="line name">Larissa.</p>
                <p class="line name">Luanny.</p>
            </div>
            <p class="line project-intro" id="founders-intro">“Somos três travestis. E estamos criando algo inédito: <span class="orby-text">Orby Chat</span>.”</p>
        </section>

        <!-- Seção 4: Detalhes do Projeto -->
        <section id="project-details" class="manifesto-section" aria-labelledby="details-line-1">
             <p class="line" id="details-line-1">“Uma rede social feita de estudo, de resistência, de sonho e de verdade.”</p>
        </section>

        <!-- Seção 5: Objetivo -->
        <section id="goal" class="manifesto-section" aria-labelledby="goal-line-1">
             <!-- Container para aplicar o efeito Glitch -->
            <div class="glitch-container" data-text="“Nosso objetivo? Entrar na lista da Forbes.”">
                 <p class="line glitch-text" id="goal-line-1">“Nosso objetivo? Entrar na lista da Forbes.”</p>
            </div>
            <p class="line goal-motivation">“Não pelo dinheiro. Mas pelo direito de sermos referência.”</p>
        </section>

         <!-- Seção 6: Luta / Futuro -->
         <section id="struggle-future" class="manifesto-section" aria-labelledby="future-line-1">
             <!-- Frases de fundo que aparecem sutilmente -->
             <div class="overlay-phrases" aria-hidden="true"> <!-- aria-hidden pois são decorativas -->
                 <span class="overlay-phrase">também posso</span>
                 <span class="overlay-phrase">também sou capaz</span>
                 <span class="overlay-phrase">mereço</span>
            </div>
            <p class="line future-statement" id="future-line-1">“Porque o futuro não pode ser contado sem nós.”</p>
        </section>

        <!-- Seção 7: Determinação -->
        <section id="determination" class="manifesto-section" aria-labelledby="determination-line-1">
            <p class="line" id="determination-line-1">“Não sabemos si vamos conseguir.”</p>
            <p class="line">“Mas alguém tem que tentar primeiro.”</p>
            <p class="line">“E si não formos nós... quem será?”</p>
        </section>

        <!-- Seção 8: Transformação / O que está sendo construído -->
        <section id="transformation" class="manifesto-section" aria-labelledby="transformation-line-1">
            <p class="line" id="transformation-line-1">“Estamos construindo mais que tecnologia.”</p>
            <p class="line build-more">“Estamos criando uma escola. Um legado. Um espaço onde travestis também programam, lideram, inovam.”</p>
            <!-- Lista de "produtos" ou entregáveis -->
            <div class="product-list" aria-label="Entregáveis do projeto">
                <span class="product-item">e-book</span>
                <span class="product-item">diário didático</span>
                <span class="product-item">comunidade viva</span>
                <span class="product-item">tecnologia inclusiva</span>
            </div>
        </section>

        <!-- Seção 9: Processo / Resistência -->
        <section id="process" class="manifesto-section" aria-labelledby="process-line-1">
            <!-- Linhas com efeito de digitação -->
            <p class="line" id="process-line-1">“Cada linha de código é resistência.”</p>
            <p class="line">“Cada passo documentado é uma ponte para outras subirem.”</p>
        </section>

        <!-- Seção 10: Clímax -->
        <section id="climax" class="manifesto-section" aria-labelledby="climax-line-1">
            <p class="line big-text" id="climax-line-1">O topo também pode ser travesti.</p>
        </section>

        <!-- Seção 11: Final / Chamada para Ação -->
        <section id="ending" class="manifesto-section" aria-labelledby="ending-cta-1">
            <div class="logo-animation">
                <!-- Logo em imagem da URL fornecida -->
                <img id="orby-logo" src="https://reprograma-t.github.io/logo.png" alt="Orby Chat Logo">
                <!-- Tagline com animação por palavra -->
                <div class="tagline" aria-label="Tagline: Travestis. Visionárias. Fundadoras.">
                    <span class="tagline-word">Travestis.</span>
                    <span class="tagline-word">Visionárias.</span>
                    <span class="tagline-word">Fundadoras.</span>
                </div>
            </div>
            <div class="call-to-action">
                <p class="line cta-line" id="ending-cta-1">Invista. Compartilhe. Sonhe com a gente.</p>
                <p class="line cta-line">Porque quando uma travesti sobe, ela puxa muitas outras junto.</p>
            </div>

            <!-- Opcional: Adicionar botões de compartilhamento aqui -->
            <!--
            <div class="share-buttons">
                <a href="https://www.facebook.com/sharer/sharer.php?u=URL_DO_SEU_MANIFESTO" target="_blank" class="share-button" aria-label="Compartilhar no Facebook">Facebook</a>
                <a href="https://twitter.com/intent/tweet?url=URL_DO_SEU_MANIFESTO&text=Também Podemos Sonhar - Manifesto Orby Chat&hashtags=TambémPodemosSonhar,OrbyChat,TravestisNaTecnologia" target="_blank" class="share-button" aria-label="Compartilhar no Twitter">Twitter</a>
                <a href="https://www.linkedin.com/shareArticle?mini=true&url=URL_DO_SEU_MANIFESTO&title=Também Podemos Sonhar - Manifesto Orby Chat&summary=Travestis criando tecnologia..." target="_blank" class="share-button" aria-label="Compartilhar no LinkedIn">LinkedIn</a>
            </div>
            -->
        </section>

    </main> <!-- Fim do #manifesto-container -->

    <!-- Schema Markup para SEO (JSON-LD) -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "Organization",
        "name": "Orby Chat",
        "url": "https://reprograma-t.github.io", /* URL principal do projeto/organização */
        "logo": "https://reprograma-t.github.io/logo.png", /* Logo principal */
        "description": "Rede social e plataforma educacional criada por travestis para promover inclusão na tecnologia.",
        "founders": [
        {
            "@type": "Person",
            "name": "Kelly"
        },
        {
            "@type": "Person",
            "name": "Larissa"
        },
        {
            "@type": "Person",
            "name": "Luanny"
        }
        ],
        "sameAs": [ /* Opcional: Adicione links para redes sociais da Orby Chat */
            /* "https://twitter.com/orbychat", */
            /* "https://www.instagram.com/orbychat/" */
        ]
    }
    </script>

    <!-- Script de Animação -->
    <script>
        const sections = document.querySelectorAll('.manifesto-section');
        let currentSectionIndex = 0; // Índice da seção atual

        // Pega os valores das variáveis CSS para usar nos cálculos de tempo
        const computedStyle = getComputedStyle(document.documentElement);
        const lineDelay = parseFloat(computedStyle.getPropertyValue('--line-delay')) * 1000; // ms
        const sectionDelay = parseFloat(computedStyle.getPropertyValue('--section-delay')) * 1000; // ms
        const transitionSpeed = parseFloat(computedStyle.getPropertyValue('--transition-speed')) * 1000; // ms
        const TYPING_SPEED_MS_PER_CHAR = 50; // Velocidade de digitação estimada

        // Função para mostrar uma seção específica e suas linhas
        function showSection(index) {
            if (index >= sections.length) {
                console.log('Fim do manifesto');
                // Opcionalmente, adicione botões de compartilhamento ou loop
                return; // Para a execução
            }

            const currentSection = sections[index];
            const previousSection = sections[index - 1];

            // Esconde a seção anterior
            if (previousSection) {
                previousSection.classList.remove('active');
            }

            // Mostra a seção atual
            currentSection.classList.add('active');

            // --- Animações específicas da seção (algumas acionadas por .active no CSS) ---
            if (currentSection.id === 'struggle-future') {
                const overlayPhrases = currentSection.querySelectorAll('.overlay-phrase');
                const linesInStruggle = currentSection.querySelectorAll('.line');
                // Atraso para frases = tempo das linhas + buffer
                const delayForOverlays = (linesInStruggle.length > 0 ? (linesInStruggle.length - 1) * lineDelay + transitionSpeed : 0) + 500;
                overlayPhrases.forEach((phrase, i) => {
                    setTimeout(() => phrase.classList.add('visible'), delayForOverlays + i * 500);
                });
            } else if (currentSection.id === 'transformation') {
                const productItems = currentSection.querySelectorAll('.product-item');
                const linesInTransformation = currentSection.querySelectorAll('.line');
                 // Atraso para produtos = tempo das linhas + buffer
                const delayForProducts = (linesInTransformation.length > 0 ? (linesInTransformation.length - 1) * lineDelay + transitionSpeed : 0) + 500;
                productItems.forEach((item, i) => {
                    setTimeout(() => item.classList.add('visible'), delayForProducts + i * 300);
                });
            }
             // Outras seções como 'climax', 'ending' (logo, tagline) têm animações
             // majoritariamente controladas via CSS pela classe .active

            // --- Animação das Linhas ---
            const lines = currentSection.querySelectorAll('.line');
            let cumulativeTime = 0; // Tempo acumulado para início da animação da linha atual

            lines.forEach((line, i) => {
                let delayForThisLine;

                if (currentSection.id === 'process') {
                    // Na seção 'process', o delay depende do fim da digitação anterior
                    if (i === 0) {
                        delayForThisLine = lineDelay; // Primeira linha usa delay padrão
                    } else {
                        // Calcula tempo da linha anterior + buffer
                        const prevLine = lines[i - 1];
                        const prevTypingDuration = (prevLine.textContent || '').length * TYPING_SPEED_MS_PER_CHAR;
                        // Inicia após o tempo acumulado anterior + duração da digitação anterior + pausa
                        delayForThisLine = cumulativeTime + prevTypingDuration + 500;
                    }
                    cumulativeTime = delayForThisLine; // Atualiza tempo acumulado para a próxima linha
                } else {
                    // Para outras seções, o delay é escalonado normalmente
                    delayForThisLine = i * lineDelay;
                }

                 // Atraso para ativar o Glitch DEPOIS da linha ficar visível
                 if (currentSection.id === 'goal' && line.classList.contains('glitch-text')) {
                    setTimeout(() => {
                        const glitchContainer = currentSection.querySelector('.glitch-container');
                        if (glitchContainer) {
                           glitchContainer.classList.add('active');
                        }
                    }, delayForThisLine + transitionSpeed); // Atraso = delay da linha + duração da animação da linha
                }


                // Define o timeout para tornar a linha visível
                setTimeout(() => {
                    line.classList.add('visible');

                    // Inicia animação de digitação para a seção 'process'
                    if (currentSection.id === 'process' && line.classList.contains('line')) {
                        const text = line.textContent || '';
                        const typingDuration = text.length * TYPING_SPEED_MS_PER_CHAR;

                        // Adiciona a classe para mostrar o cursor piscando
                        line.classList.add('typing');
                        // Define a animação de digitação via JS para controle preciso da duração
                        line.style.width = '0'; // Começa sem largura
                        line.style.animation = `typing ${typingDuration / 1000}s steps(${text.length}, end) forwards, blink-caret .75s step-end infinite`;

                        // Remove a classe 'typing' e a animação de digitação após terminar
                        // para manter o texto visível e remover o cursor
                        setTimeout(() => {
                            line.classList.remove('typing');
                            line.style.animation = ''; // Remove animações inline
                             // Garante que a largura final seja mantida
                            line.style.width = 'fit-content';
                        }, delayForThisLine + typingDuration + 100); // Espera terminar a digitação + buffer
                    }

                }, delayForThisLine);
            });

            // --- Calcula a Duração Total da Seção Atual ---
            let sectionDuration = 0;
            const lastLineIndex = lines.length > 0 ? lines.length - 1 : -1;

            if (lastLineIndex === -1) {
                sectionDuration = 0; // Seção sem linhas
            } else if (currentSection.id === 'process') {
                // Duração é até o fim da digitação da última linha
                const lastLine = lines[lastLineIndex];
                const lastLineTypingDuration = (lastLine.textContent || '').length * TYPING_SPEED_MS_PER_CHAR;
                sectionDuration = cumulativeTime + lastLineTypingDuration + 500; // Tempo acumulado + digitação da última + buffer
            } else {
                 // Duração normal: delay da última linha + sua animação de entrada
                 sectionDuration = lastLineIndex * lineDelay + transitionSpeed;

                 // Considera tempos extras de animações específicas que ocorrem *depois* das linhas
                 if (currentSection.id === 'transformation') {
                    const productItems = currentSection.querySelectorAll('.product-item');
                    if (productItems.length > 0) {
                        const delayForProductsStart = (lines.length > 0 ? (lines.length - 1) * lineDelay + transitionSpeed : 0) + 500;
                        const lastProductDelay = (productItems.length - 1) * 300;
                        const productAnimationDuration = 600; // Duração da animação do item
                        const totalProductTime = delayForProductsStart + lastProductDelay + productAnimationDuration;
                        sectionDuration = Math.max(sectionDuration, totalProductTime);
                    }
                 } else if (currentSection.id === 'struggle-future') {
                    const overlayPhrases = currentSection.querySelectorAll('.overlay-phrase');
                     if (overlayPhrases.length > 0) {
                        const delayForOverlaysStart = (lines.length > 0 ? (lines.length - 1) * lineDelay + transitionSpeed : 0) + 500;
                        const lastOverlayDelay = (overlayPhrases.length - 1) * 500;
                        const overlayAnimationDuration = 1000;
                        const totalOverlayTime = delayForOverlaysStart + lastOverlayDelay + overlayAnimationDuration;
                        sectionDuration = Math.max(sectionDuration, totalOverlayTime);
                     }
                 } else if (currentSection.id === 'ending') {
                    // Duração baseada no mais longo: linhas CTA ou logo+tagline
                    const ctaLinesDuration = sectionDuration; // Já calculado acima

                    const logoAnimationTime = 1500; // Duração CSS
                    const lastTaglineWordDelay = 3100; // Delay CSS
                    const taglineWordAnimationTime = 600; // Duração CSS
                    const logoTaglineTotalTime = Math.max(logoAnimationTime, lastTaglineWordDelay + taglineWordAnimationTime);

                    sectionDuration = Math.max(ctaLinesDuration, logoTaglineTotalTime) + 500; // Pega o maior tempo + buffer
                 }
            }


            // --- Chama a Próxima Seção ---
            setTimeout(() => {
                // Limpeza antes de passar para a próxima seção
                if (currentSection.id === 'goal') {
                    const glitchContainer = currentSection.querySelector('.glitch-container');
                     if (glitchContainer) {
                       glitchContainer.classList.remove('active');
                    }
                }
                // Remover estilos inline da animação de digitação
                if (currentSection.id === 'process') {
                    lines.forEach(line => {
                         line.style.animation = '';
                         line.style.width = ''; // Reseta largura se necessário
                    });
                }

                showSection(index + 1);
            }, sectionDuration + sectionDelay); // Tempo total da seção + delay padrão entre seções
        }

        // --- Inicia a Sequência do Manifesto ---
        document.addEventListener('DOMContentLoaded', () => {
            // Pequeno atraso inicial
            setTimeout(() => {
                showSection(currentSectionIndex);
            }, 500);
        });
    </script>

</body>
</html>
